{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"OQL"},{"location":"/index.html#oql","text":"Object Query Language (OQL) is a simple relational database query language inspired by GraphQL and SQL, but designed to be translated query-for-query into database engine specific SQL, with identical behaviour across supported engines.","title":"OQL"},{"location":"/overview.html","text":"","title":"Overview"},{"location":"/overview.html#overview","text":"OQL is a language for querying a relational database. The query syntax draws inspiration from GraphQL and is similar, but with many differences. Some capabilities missing from GraphQL have been added, and some capabilities found in GraphQL have a different syntax. We believe that much of conventional SQL syntax is still preferable to creating a completely new syntax for every single feature of the query language (i.e., conventional syntax wherever possible). However, whereas SQL can be seen as a “low level” relational query language, OQL takes a higher level Entity-Relationship (ER) Model view of the database.\nThe name “OQL” refers to both a software library, and a query language implemented within that library. The OQL library provides support for data retrieval (via the OQL query language) as well as a query builder for constructing queries in programmatically. There are also class methods for performing all kinds of mutations, including mutations that support the ER view of the database. Furthermore, query and mutation operations all abide by the supplied ER data model.\nSome features of OQL include:\nthe query language is similar to GraphQL in that query results have exactly the structure requested in the query (i.e., you get what you ask for) uses a very simple Entity-Relationship Model description of the database works with the PostgreSQL database system designed to work with existing databases without having to change the database at all","title":"Overview"},{"location":"/installation.html","text":"","title":"Installation"},{"location":"/installation.html#installation","text":"","title":"Installation"},{"location":"/installation.html#typescript-javascript","text":"There is a Node.js module available through the npm registry.\nInstall using the npm install command:\nnpm install @vinctus/oql\nTypeScript declarations are included in the package.","title":"TypeScript/JavaScript"},{"location":"/installation.html#scala-js","text":"There is a Scala.js library available through Github Packages.\nAdd the following lines to your build.sbt:\nexternalResolvers += \"OQL\" at \"https://maven.pkg.github.com/vinctustech/oql\"\n\nlibraryDependencies += \"com.vinctus\" %%% \"-vinctus-oql\" % \"1.0.0-RC.3.23\"\n\nCompile / npmDependencies ++= Seq(\n  \"pg\" -> \"8.5.1\",\n  \"@types/pg\" -> \"7.14.7\"\n)","title":"Scala.js"},{"location":"/usage.html","text":"","title":"Usage"},{"location":"/usage.html#usage","text":"","title":"Usage"},{"location":"/api.html","text":"","title":"API"},{"location":"/api.html#api","text":"","title":"API"},{"location":"/examples.html","text":"","title":"Examples"},{"location":"/examples.html#examples","text":"","title":"Examples"},{"location":"/datatypes.html","text":"","title":"Datatypes"},{"location":"/datatypes.html#datatypes","text":"A datatype, in OQL, is distinct from the notion of an attribute type. Specifically, datatypes are a subclass of attribute type. Any given OQL datatype is guaranteed to have the same meaning across supported engines that implement the given datatype in some way.","title":"Datatypes"},{"location":"/datatypes.html#text","text":"In OQL, there is currently a single datatype for representing character string or textual data: text.\nThe text datatype corresponds to the PostgreSQL TEXT datatype and materializes as a TypeScript string primitive or a Scala String type object.","title":"Text"},{"location":"/datatypes.html#numeric","text":"There are four different categories of numerical data currently in OQL.","title":"Numeric"},{"location":"/datatypes.html#small-integers","text":"These are integers in the range of approximately -2.1 billion to +2.1 billion. In OQL, this is the integer datatype, which has two synonyms: int and int4.\nThe integer datatype corresponds to the PostgreSQL INTEGER datatype and materializes as a TypeScript number primitive or a Scala Int type object.","title":"Small integers"},{"location":"/datatypes.html#arbitrarily-large-integers","text":"These are integers that can be of any size. In OQL, this is the bigint datatype.\nThe bigint datatype corresponds to the PostgreSQL BIGINT datatype and materializes as a TypeScript bigint primitive or a Scala BitInt type object.","title":"Arbitrarily large integers"},{"location":"/datatypes.html#double-precision-floating-point","text":"These are floating point numbers in a standard (IEEE 754) double precision binary representation with 15 significant digits. In OQL, this is the float datatype, which has one synonym: float8.\nThe float datatype corresponds to the PostgreSQL DOUBLE PRECISION datatype and materializes as a TypeScript number primitive or a Scala Double type object.","title":"Double precision floating point"},{"location":"/datatypes.html#arbitrary-precision","text":"These are arbitrarily precise floating point numbers stored in a decimal representation. In OQL, this is the decimal(p, s) parametric datatype, where p is the precision giving the number of significant digits, and s is the scale giving the number of digits after the decimal point.\nThe decimal(p, s) datatype corresponds to the PostgreSQL NUMERIC(p, s) parametric datatype and materializes as a big.js (JavaScript library) Big type object or a Scala BigDecimal type object.","title":"Arbitrary precision"},{"location":"/datatypes.html#boolean","text":"","title":"Boolean"},{"location":"/datatypes.html#uuid","text":"","title":"UUID"},{"location":"/datatypes.html#time-and-date","text":"","title":"Time and Date"},{"location":"/syntax.html","text":"","title":"Syntax"},{"location":"/syntax.html#syntax","text":"The following syntax (or railroad) diagrams of both the data modeling and query language provide a clear description of those languages. The syntax for json (JSON syntax) has been omitted.","title":"Syntax"},{"location":"/syntax.html#data-modeling-language","text":"An “Entity-Relationship” style language is used to describe the database. Only the portions of the database for which OQL is being used need to be described.","title":"Data Modeling Language"},{"location":"/syntax.html#data-modeling-grammar-rules","text":"Model The complete data model is a series of entities. Entity Entities correspond to tables in the database. An entity comprises an identifier matching the name of the corresponding table, which can be given an alias, and a series of attributes. Identifier An identifier can have letters, digits, underscores, and dollar signs, but may not begin with a digit. Alias Aliases are identifiers. Attribute Attributes correspond to columns in a table, if they have a datatype, or a simple entity type (i.e., just the name of an entity). An attribute that begins with an asterisk is the primary key. The name of an attribute can be aliased. An attribute that ends with an exclamation mark can’t be null or excluded when inserting. Type There are several kinds of attribute types: DataType corresponding to a database engine datatype. These attributes correspond to table columns that are not foreign keys. EntityName representing the many-to-one relationship (from the point of view of the current entity). This is the entity relationship type that corresponds to a table column that is a foreign key. [ EntityName ] or [ EntityName ] . AttributeName representing the one-to-many relationship (from the point of view of the current entity). This is the array type that represents all the entities (rows) that are referencing the current entity. [ EntityName ] ( EntityName ) or [ EntityName ] . AttributeName ( EntityName ) representing the many-to-many relationship. The second EntityName in parentheses refers to the junction or link entity (table). < EntityName > or < EntityName > . AttributeName representing the one-to-many relationship (the current entity is the one being referenced by a foreign key). DataType Any one of the basic datatypes that are commonly support by database systems. Any group of datatypes that begin with the same spelling (beyond the first one or two letters) are synonymous (e.g., bool and boolean refer to the same datatype). EntityName An EntityName is an identifier that corresponds either to the identifier given as the entity name if it wasn’t aliased, or to the alias if it was. AttributeName An AttributeName is an identifier that corresponds either to the identifier given as the attribute name if it wasn’t aliased, or to the alias if it was.","title":"Data Modeling Grammar Rules"},{"location":"/syntax.html#query-language","text":"The query language is inspired by GraphQL. In the following grammar, all keywords (double-quoted string literals) are case-insensitive.","title":"Query Language"},{"location":"/syntax.html#query-grammar-rules","text":"query A data retrieval query expression begins with the name of the entity being queried followed by zero or more optional relational operations: project This relational operation specifies the structure of the result. If omitted, the result will comprise all datatype attributes (i.e., columns that are not foreign keys) only, in the order in which they were defined in the data model. The fact that relational attributes must be explicitly specified prevents circularity as well as the retrieval of, possibly very large amounts of unneeded data. The structure of the result is basically a sequence of expressions each with an (often implicit) label. attributeProject The syntax of an attribute within a project is essentially a possibly optional label, followed by an expression, or an inner query if it is a reference to an array type attribute. label Results are in the form of objects which can are thought of as a list of property/value pairs. Therefore, in order to build a result, the property names have to be known. A label, when it is given becomes the property name of the associated value. If omitted, there are simple obvious rules for inferring it. entityName An entityName is an identifier that names an entity (table) or it’s alias. attributeName An attributeName is an identifier that names a column (attribute) or it’s alias. applyExpression Function application has conventional syntax (e.g., SUM(cost)). Currently, function names pass through transpilation unchecked. attributeExpression An attributeExpression is an identifier that names an attribute, whether it’s a column or not, or it’s alias. qualifiedAttributeExpression This is a reference to an attribute that essentially traverses or dereferences a foreign key. select The select relational operation contains a boolean row selection or filter expression. If omitted, all rows will be retrieved.The row selection condition must be a boolean valued expression. group The group operation contains a series of one or more grouping expressions by which an array result will be grouped. order The order operation contains a series of one or more ordering expressions by which an array result will be ordered. Database engines differ in how they order results that contain null values. OQL guarantees a consistent default behaviour across supported engines. For ascending ordering, nulls are first. For descending ordering, nulls are last. restrict This is really two operations that tend to go together: offsetting or skipping an initial number of results, and limiting the number of results. The first integer is the offset (zero if omitted), and the second is the limit (unlimited if omitted). booleanExpression A booleanExpression is a boolean (true or false) valued expression that may be a disjunction (logical “or”) of two or more boolean valued expressions. andExpression An andExpression is a boolean valued expression that may be a conjunction (logical “and”) of two or more boolean valued expressions. notExpression A notExpression allows a boolean valued expression to be negated. booleanPrimary These are the most basic kinds of boolean valued expressions. expression multiplicative primary identifier string There are two types of string literals: single quoted and double quoted. Single quoted strings are delimited by single quotes, and so cannot contain a single quote unless it is escaped. Double quoted strings are delimited by double quotes, and so cannot contain a double quote unless it is escaped. Strings can have the following characters and escape sequences: any unicode character except for: characters in the range \\x00-\\x1F, character \\x7F backslashes are not allowed unless followed by one of the characters: \\'\"bfnrtu if a backslash is followed by a u, then 4 hexadecimal digits must follow after that","title":"Query Grammar Rules"},{"location":"/supported-engines.html","text":"","title":"Supported Engines"},{"location":"/supported-engines.html#supported-engines","text":"","title":"Supported Engines"},{"location":"/supported-engines.html#postgresql","text":"","title":"PostgreSQL"},{"location":"/release-notes.html","text":"","title":"Release Notes"},{"location":"/release-notes.html#release-notes","text":"","title":"Release Notes"},{"location":"/release-notes.html#1-0-0-rc-3-23","text":"second feature-complete release candidate with no known bugs fixed a regression: escaping an apostrophe","title":"1.0.0-RC.3.23"},{"location":"/release-notes.html#1-0-0-rc-3-22","text":"first feature-complete release candidate","title":"1.0.0-RC.3.22"}]}